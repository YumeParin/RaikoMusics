% =====================================================================
% PRÉAMBULE
% =====================================================================
\documentclass[12pt,a4paper]{article} % Définit le type de document, la taille de la police et le format du papier.

% --- Packages de Langue et de Mise en Page ---
\usepackage[french]{babel} % Définit la langue du document en français pour la typographie et la césure.
\usepackage[T1]{fontenc} % Encodage des polices, essentiel pour un rendu correct des caractères accentués.
\usepackage[lmargin=2.5cm,rmargin=2.5cm,tmargin=2.5cm,bmargin=2.5cm]{geometry} % Définit les marges de la page.
\usepackage{setspace} % Permet de contrôler l'interligne.
\setstretch{1.5} % Définit un interligne de 1.5.

% --- Packages Techniques et Visuels ---
\usepackage{graphicx} % Permet d'inclure des images.
\usepackage{xcolor} % Permet de définir et d'utiliser des couleurs.
\usepackage{hyperref} % Crée des liens cliquables (pour les références, URL, table des matières).
\usepackage{placeins}
\usepackage{csquotes} % Améliore la gestion des guillemets.
\usepackage{minted} % Pour l'affichage de code avec coloration syntaxique.
\usepackage{caption} % Personnalisation des légendes des flottants (figures, tables).
\usepackage{subcaption} % Support pour les sous-figures et sous-légendes.
\usepackage{longtable,booktabs,array} % Outils avancés pour la création de tableaux.

% --- Configurations Personnalisées ---

% Définition d'une couleur pour le fond des blocs de code
\definecolor{LightGray}{gray}{0.95}

% Configuration des couleurs des hyperliens
\hypersetup{
    colorlinks=true,         % Liens colorés plutôt qu'encadrés.
    linkcolor={blue},        % Couleur des liens internes (table des matières, références).
    citecolor={blue},        % Couleur des citations bibliographiques.
    filecolor={maroon},      % Couleur des liens vers des fichiers locaux.
    urlcolor={blue}          % Couleur des liens URL.
}

% --- Métadonnées du Document ---
\title{Rapport de Travail\\ \vspace{0.5cm} \Large Projet RaikoMusics}
\author{Antoine Torrez Suzano}
\date{\today}

% Commande pour ajouter un sous-titre (facultatif)
\makeatletter
\providecommand{\subtitle}[1]{%
    \apptocmd{\@title}{\par {\Large\bfseries #1 \par}}{}{}
}
\makeatother
\subtitle{Développement d'une application de streaming audio}

% =====================================================================
% DÉBUT DU DOCUMENT
% =====================================================================
\begin{document}

% --- Page de Garde ---
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    % Mettre le logo de ton école ici
    % \includegraphics[width=0.4\textwidth]{logo_ecole.png}\\[2cm]
    
    \Huge\bfseries Raiko Musics Project\\[0.5cm]
    \Large Rapport de Travail\\[2cm]
    
    \Large Antoine Torrez Suzano \\[2cm]
    
    \vfill % Pousse le contenu suivant vers le bas de la page
    
    \large
    % À adapter selon ton contexte
    Maître de classe : Bracamonte Javier \\[1cm]
    
    % Mettre le nom de ton école/entreprise
    Ceff Industrie\\
    Département Informatique\\
    Saint-Imier, Suisse\\[1cm]
    
    \today
\end{titlepage}

\vspace{\fill}

% --- Résumé ---
\newpage
\section*{Résumé}
\addcontentsline{toc}{section}{Résumé}

Ce document constitue le rapport du projet Raiko Musics Project. 
C'est une application Web de streaming musical conçue en vue du Travail Pratique Individuel. 
Destiné à être simple et minimaliste, le but principal de ce projet était de servir de prétexte afin 
d'affiner mes connaissances et d'acquérir une maîtrise pratique de technologie clés du domaine du DevOps.

L'application se repose sur une architecture conteneurisé avec Docker, un backend utilisant Node.js (Express, Multer) qui gèrent les fichiers audio internes, ainsi qu'une interface frontend simple. Un pipeline CI/CD a été mis en place avec GitHub Action afin d'automatiser le déploiement après un changement du projet.

Les fonctionnalités essentielles : lecture, téléversement et suppression de musiques ont été implémentées et validées à travers une série de tests manuels. Des tests unitaires réalisés avec Jest ont permis d’assurer une couverture quasi complète de l’API. Ce projet constitue ainsi une base solide pour de futurs développements et a permis une montée en compétences significative dans les domaines du DevOps et de l’ingénierie logicielle.

\vspace{1cm}
\textbf{Mots-clés :} DevOps, CI/CD, GitHub Actions, Docker, Backend, Frontend, Tests, Futur, Fonctionnalité.

% --- Table des Matières ---
\newpage
\renewcommand*\contentsname{Table des matières}
{
    \hypersetup{linkcolor=black} % Met les liens de la TDM en noir pour l'impression
    \tableofcontents
}
\newpage
\pagenumbering{arabic} % La numérotation des pages commence ici (page 1)
\setstretch{1.5}

% =====================================================================
% CORPS DU RAPPORT
% =====================================================================

\section{Introduction}

Dans le cadre de ma 4ème année de formation CFC, il m'a été demandé de créer un projet 
d'entraînement afin de me préparer au futur Travail Pratique Individuel (TPI) qui décidera
la suite de mon parcours professionnel.
L'objectif principal de la création du projet Raiko Musics Project n'est pas de faire de la 
concurrence à d'autres géants du domaine de streaming musical, mais d'avoir un prétexte afin
d'apprendre un ensemble de technologies clés dans le domaine du DevOps. 

La problématique fictive du projet était : avoir une application simple, accessible et rapide 
pour écouter et publier de la musique sans téléchargement ni compte requis.

La problématique réelle du projet était : Comment concevoir, développer et déployer une application web moderne en automatisant au maximum le processus de mise à jour ? Ce défi comprend des aspects variés tel que la gestion d'un serveur cloud, le développement backend pour la gestion des conteneurs, et surtout la création du pipeline CI/CD.

\section{Cahier des Charges}

Cette section définit les objectifs, les fonctionnalités attendues et les contraintes du projet RaikoMusics.

\subsection{Objectifs du Projet}
Les buts principaux du projet RaikoMusics sont les suivants :
\begin{itemize}
    \item \textbf{Apprentissage :} Acquérir une expérience pratique et approfondir mes connaissances sur des technologies spécifiques (streaming, CI/CD, Docker).
    \item \textbf{Fondation Solide :} Construire une application avec une architecture saine et modulaire, permettant d'implémenter facilement de nouvelles fonctionnalités à l'avenir.
    \item \textbf{Rapidité et Simplicité :} Offrir une expérience utilisateur épurée, sans fonctionnalités superflues, pour écouter, publier et gérer de la musique.
\end{itemize}

\subsection{Exigences Fonctionnelles (Critères d'Acceptation)}
Pour que la première version du projet soit considérée comme achevée, les exigences suivantes devaient être satisfaites :
\begin{itemize}
    \item \textbf{EF-01 :} L'utilisateur doit pouvoir lire une piste musicale depuis le serveur via une interface web.
    \item \textbf{EF-02 :} L'utilisateur doit pouvoir téléverser (publier) de nouvelles pistes musicales sur le serveur.
    \item \textbf{EF-03 :} L'utilisateur doit pouvoir supprimer une piste musicale.
\end{itemize}

\subsection{Exigences Non-Fonctionnelles}
\begin{itemize}
    \item \textbf{ENF-01 :} L'application doit être déployée via des conteneurs Docker.
    \item \textbf{ENF-02 :} Le processus de déploiement doit être entièrement automatisé : une modification poussée sur la branche \texttt{main} du dépôt Git doit déclencher une mise à jour automatique de l'application en production (Pipeline CI/CD).
    \item \textbf{ENF-03 :} L'application doit être accessible publiquement via une URL sur Internet.
    \item \textbf{ENF-04 :} Le code source du projet doit être ouvert et publié sous licence MIT.
\end{itemize}


\section{Analyse et Conception}

Cette section décrit l'architecture globale de l'application et justifie les choix technologiques effectués pour répondre au cahier des charges.

\subsection{Architecture Globale}
RaikoMusics est conçu selon une architecture client-serveur découplée, composée de plusieurs services conteneurisés communiquant entre eux.



Les composants principaux sont :
\begin{itemize}
    \item \textbf{Un service Frontend :} Une application web mono-page (SPA) responsable de l'interface utilisateur.
    \item \textbf{Un service Backend (API) :} Une API RESTful qui gère la logique métier : la gestion des métadonnées des musiques, requêtes de suppression et ajouts des musiques.
    \item \textbf{Un système de stockage de fichiers :} Pour les fichiers audio eux-mêmes, la pochette de musique (.jpg) et le fichier de métadonnées des pistes (titre, artiste). Pour la simplicité, un volume Docker a été utilisé.
\end{itemize}

\begin{figure}[h!]
    \centering
    % Tu peux créer un schéma avec un outil comme diagrams.net et l'exporter en PNG
    \fbox{\parbox{0.9\textwidth}{
            \includegraphics[width=0.9\textwidth]{architecture.png}
    }}
    \caption{Schéma de l'architecture de RaikoMusics.}
    \label{fig:architecture}
\end{figure}

\subsection{Choix Technologiques}
\begin{itemize}
    \item \textbf{Docker :} Choisi pour la conteneurisation. Il permet d'isoler les services, de garantir la reproductibilité des environnements et de simplifier grandement le déploiement.
    \item \textbf{GitHub Actions :} Intégré directement à GitHub, cet outil a été choisi pour sa simplicité de mise en œuvre pour créer le pipeline CI/CD. Il permet de construire les images Docker, de les pousser vers un registre et de déclencher le déploiement sur le serveur à chaque push.
    \item \textbf{Streaming via "HTTP Range Requests" :} Pour la première version, cette technique a été retenue pour sa simplicité. Elle permet au client de demander uniquement des parties spécifiques d'un fichier, ce qui est la base pour la lecture en streaming et la possibilité de se déplacer dans la piste de lecture.
    \item \textbf{Backend : [Node.js avec Express et Multer]} : Ces technologies constituent la base du service backend. Express est utilisé pour l’implémentation de l’API REST, tandis que Multer gère efficacement le téléversement et la manipulation des fichiers au sein du conteneur Docker hébergeant l’API.
    \item \textbf{Frontend : [HTML / JavaScript]} : Pour le Frontend, l'utilisation de l'IA a été privilégiée pour accélérer la production du code HTML/JS, me permettant de consacrer la majeure partie du temps à la complexité du Backend et de l'architecture DevOps qui est l'objectif principal du projet.
    \item \textbf{Client Desktop : [Electron]} : En complément de l’application Web, un client de bureau a été développé avec Electron. Il se contente d’embarquer un navigateur Chromium et d’afficher directement le site RaikoMusics, offrant ainsi une version installable de l’application sans logique métier supplémentaire.


\end{itemize}

\section{Implémentation}
% Dans cette section, tu décrirais comment tu as codé le projet.
% Exemple :
Cette phase a consisté à traduire la conception en code fonctionnel. Le développement a été divisé en plusieurs étapes clés.
\subsection{Développement du Backend}

Le backend repose sur une API REST développée avec Express. Son rôle est d’assurer la gestion des fichiers audio, des métadonnées et des opérations de consultation et de suppression.

\subsubsection{Infrastructure Express}
L’infrastructure de base inclut la configuration du serveur, les middlewares généraux (JSON, formulaires, CORS) ainsi que le routage principal regroupant l’ensemble des endpoints de l’API.

\subsubsection{Gestion des Téléversements}
La gestion des fichiers a été confiée à un middleware personnalisé en utilisant \texttt{Multer}.  
Il permet :
\begin{itemize}
    \item le filtrage des types de fichiers (MP3 et images) ;
    \item la création d’un dossier unique par musique ;
    \item la mise en place de limite de taille et nombre de fichier.
\end{itemize}

\subsubsection{Contrôleurs de l’API}
Les contrôleurs réalisent la logique de l'API :
\begin{itemize}
    \item upload : vérification des champs requis, stockage des fichiers et création du \texttt{metadata.json} ;
    \item lecture : récupération de la liste des musiques via les métadonnées stockées ;
    \item suppression : suppression complète d’une musique et de son dossier associé.
\end{itemize}


\subsection{Mise en Place du Pipeline CI/CD}
Le pipeline, défini dans un fichier YAML pour GitHub Actions, exécute les étapes suivantes :
\begin{enumerate}
    \item Déclenchement sur un push sur la branche `main`.
    \item Checkout du code source.
    \item Construction des images Docker pour le frontend et le backend.
    \item Publication des images sur un registre (ex: Docker Hub ou GitHub Container Registry).
    \item Connexion en SSH au serveur de production pour lancer un script de déploiement qui met à jour les services.
\end{enumerate}

\subsection{Client Desktop avec Electron}

En complément de l’interface Web, un client desktop a été réalisé à l’aide du framework Electron. 
L’objectif était de fournir une version installable de RaikoMusics pour PC ainsi que découvrir le framework Electron.

L’application Electron se compose principalement d’un script \texttt{main} qui crée une fenêtre \texttt{BrowserWindow} embarquant un moteur Chromium. 
Au lancement, cette fenêtre charge directement l’URL publique de l’application Web RaikoMusics. 
Aucune logique métier n’est implémentée côté client : toute la logique reste centralisée dans l’API et le frontend Web, ce qui simplifie la maintenance.


\section{Tests et Validation}
% Ici, tu expliques comment tu as vérifié que tout fonctionnait.
Pour garantir la qualité et la conformité de l'application avec le cahier des charges, une série de tests manuels a été effectuée.

\begin{table}[h!]
    \centering
    \caption{Validation des exigences fonctionnelles.}
    \label{tab:validation}
    \begin{tabular}{@{}lp{0.6\textwidth}l@{}}
        \toprule
        \textbf{ID} & \textbf{Scénario de test} & \textbf{Résultat} \\
        \midrule
        EF-01 & 1. Ouvrir l'application. 2. Cliquer sur une musique. 3. Vérifier que la musique se lance. & Conforme \\
        EF-02 & 1. Cliquer sur "Publier". 2. Sélectionner un fichier MP3. 3. Valider. 4. Vérifier que la nouvelle musique apparaît dans la liste. & Conforme \\
        EF-03 & 1. Accèder à la page de gestion des musiques. 2. Supprimer une musique en cliquant l'icone de suppression. 3. Vérifier que la musique supprimée a disparu de la librairie & Conforme \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{table}[h!]
    \centering
    \caption{Validation des exigences Non-Fonctionnelles.}
    \label{tab:validation-non-fonctionnelles}
    \begin{tabular}{@{}lp{0.6\textwidth}l@{}}
        \toprule
        \textbf{ID} & \textbf{Scénario de test} & \textbf{Résultat} \\
        \midrule
        EFN-01 & 1. Lancement du "Docker compose" localement. 2. accès au site web et api via l'adresse des conteneurs. & Conforme \\
        EFN-02 & 1. Modification du fichier "HTML" du "Homepage". 2. Commit Push de la modification sur la branche "main". 3. Vérification du changement sur le site web en ligne.  & Conforme \\
        EFN-03 & 1. Ouverture de navigateurs internet(Chrome, Edge, Firefox). 2. Accès au site web via l'url "http://34.79.6.219/" depuis chaque navigateur & Conforme \\
        EFN-04 & 1. Accès au répertoire GitHub suivant: "https://github.com/YumeParin/RaikoMusics" & Conforme \\
        \bottomrule
    \end{tabular}
\end{table}
\FloatBarrier
\vspace{0.5cm}

Des tests unitaires ont aussi été réalisés avec le framework de test javascript "Jest" pour tous les fichiers avec 95\%  du code source de l'API RESTFUL de RaikoMusics 

\section{Conclusion}

Le projet RaikoMusics a permis d'atteindre l'ensemble des objectifs fixés dans le cahier des charges. Une application de streaming musical fonctionnelle a été développée et déployée avec succès, en utilisant une chaîne d'outils DevOps moderne.

Sur le plan personnel, ce projet a été une expérience d'apprentissage extrêmement riche. Il m'a permis de monter en compétence sur la conteneurisation avec Docker et, surtout, de démystifier la mise en place d'un pipeline CI/CD complet avec GitHub Actions. La principale difficulté a résidé dans la configuration initiale du déploiement automatisé, mais sa résolution a été très formatrice.

Le projet est aujourd'hui une fondation stable, prête à évoluer.

\subsection{Perspectives et Améliorations Futures}
Plusieurs axes d'amélioration sont envisagés pour les versions futures de RaikoMusics :
\begin{itemize}
    \item \textbf{Amélioration du Streaming :} Remplacer les "HTTP Range Requests" par un protocole de streaming adaptatif comme HLS (HTTP Live Streaming) pour une meilleure performance et une adaptation à la bande passante de l'utilisateur.
    \item \textbf{Gestion des Utilisateurs :} Implémenter un système d'inscription et de connexion pour que les utilisateurs puissent gérer leurs propres musiques et créer des playlists personnelles.
    \item \textbf{Algorithme de Recommandation :} Développer un système simple de recommandation basé sur les écoutes.
    \item \textbf{Amélioration de l'Interface :} Enrichir l'interface utilisateur avec plus de fonctionnalités (file d'attente, recherche, etc.).
\end{itemize}

\end{document}